@using PDF_IT_Yourself.Services
@inject PagePickerTool PagePickerTool
@implements IAsyncDisposable

@if (!string.IsNullOrWhiteSpace(Error))
{
    <div class="alert alert-danger">@Error</div>
}

@if (!HasPdf)
{
    <div class="text-muted">No PDF loaded.</div>
    return;
}

@if (_loading)
{
    <div class="text-muted">Generating preview…</div>
}

<div class="cover-card">
    <div class="thumb-frame cover-frame">
        @if (!string.IsNullOrWhiteSpace(_coverUrl))
        {
            <img class="thumb-img" src="@_coverUrl" alt="PDF preview (page 1)" />
        }
        else
        {
            <div class="thumb-skeleton" aria-hidden="true"></div>
        }
    </div>

    @if (ShowMeta)
    {
        <div class="cover-meta">
            <div class="fw-semibold">@Title</div>
            <div class="text-muted small">
                @PageCount page(s) • @FormatBytes(PdfBytes!.Length)
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public byte[]? PdfBytes { get; set; }
    [Parameter] public int PageCount { get; set; }
    [Parameter] public double Scale { get; set; } = 0.4;

    // optionnel
    [Parameter] public bool IsBusy { get; set; }
    [Parameter] public string? Error { get; set; }
    [Parameter] public bool ShowMeta { get; set; } = true;
    [Parameter] public string Title { get; set; } = "PDF Preview";
    [Parameter] public int PageIndex0Based { get; set; } = 0; // par défaut première page

    private string? _coverUrl;
    private bool _loading;

    private string? _pdfKey;
    private CancellationTokenSource? _cts;

    private bool HasPdf => PdfBytes is { Length: > 0 } && PageCount > 0;

    protected override async Task OnParametersSetAsync()
    {
        if (!HasPdf)
            return;

        int safeIndex = Math.Clamp(PageIndex0Based, 0, Math.Max(0, PageCount - 1));
        var newKey = ComputeKey(PdfBytes!, PageCount, Scale, safeIndex);

        if (_pdfKey == newKey && !string.IsNullOrWhiteSpace(_coverUrl))
            return;

        _pdfKey = newKey;
        await RestartAsync(safeIndex);
    }

    private async Task RestartAsync(int pageIndex)
    {
        Cancel();

        // revoke old blob url
        if (!string.IsNullOrWhiteSpace(_coverUrl) && _coverUrl.StartsWith("blob:"))
        {
            try { await PagePickerTool.RevokeObjectUrlAsync(_coverUrl); } catch { }
        }
        _coverUrl = null;

        _cts = new CancellationTokenSource();
        var ct = _cts.Token;

        _loading = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            await PagePickerTool.EnsureLoadedAsync(PdfBytes!, ct);
            _coverUrl = await PagePickerTool.GetThumbnailObjectUrlAsync(PdfBytes!, pageIndex, Scale, ct);
        }
        catch (OperationCanceledException)
        {
            // ok
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void Cancel()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _cts = null;
    }

    private static string ComputeKey(byte[] bytes, int pageCount, double scale, int pageIndex)
    {
        int len = bytes.Length;
        uint head = len >= 4 ? BitConverter.ToUInt32(bytes, 0) : 0;
        uint tail = len >= 4 ? BitConverter.ToUInt32(bytes, len - 4) : 0;
        return $"{len}:{head}:{tail}:{pageCount}:{scale}:{pageIndex}";
    }

    private static string FormatBytes(long bytes)
    {
        string[] sizes = ["B", "KB", "MB", "GB"];
        double v = bytes;
        int i = 0;
        while (v >= 1024 && i < sizes.Length - 1) { v /= 1024; i++; }
        return $"{v:0.#} {sizes[i]}";
    }

    public async ValueTask DisposeAsync()
    {
        Cancel();

        if (!string.IsNullOrWhiteSpace(_coverUrl) && _coverUrl.StartsWith("blob:"))
        {
            try { await PagePickerTool.RevokeObjectUrlAsync(_coverUrl); } catch { }
        }
    }
}